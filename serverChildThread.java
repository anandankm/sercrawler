import java.io.*;
import java.util.ArrayList;
import java.net.*;
/*
 * This child thread is actually created by
 * broker.
 */
public class serverChildThread extends Thread{
		
	private Socket connectionSocket = null;
	
	private PrintWriter out = null;
	
	private BufferedReader in = null;
	
	private Repository Rp = new Repository();
	
	public serverChildThread (Socket cxnSocket) {
		
		this.connectionSocket = cxnSocket;
		
	}
	
	public void run() {
		
		/*
		 * Input, output streams for the socket
		 */
		String inputLine  = null;
		
		String outputLine = null;
		
		try {
			
			this.out = new PrintWriter(
	                connectionSocket.getOutputStream(), true);
			
			this.in = new BufferedReader(
	                  new InputStreamReader(
	                      connectionSocket.getInputStream()));
	
			inputLine = in.readLine();
			
		} catch (IOException ie) {
		
			System.out.println("broker Child thread unable to read Hello...");
			//ie.printStackTrace();
		
		} 
	
		if (inputLine.equalsIgnoreCase("Hello")) {
			
			System.out.println("Service Provider says 'Hello'...");
			
			/*
			 * Broker sends back 'Hi'
			 */
			
			outputLine = "HI\n";
			
			out.print(outputLine);
			
			out.flush();
			
		} else {
			
			System.out.println("Input from Service Provider does not equal 'Hello'");
			
			outputLine = "ERROR 0x002\n";
			
			out.print(outputLine);
			
			out.flush();
			
			/*
			 * Once ReceivedBye is set to true, broker ends the connection.
			 * Note that here childthread did not send BYE, but the connection is ended because,
			 * the childthread did not send appropriate HELLO protocol message to start.
			 */
			Rp.ReceivedBye = true;
			
		}
		
		while (!Rp.ReceivedBye) {
			
			
			/*
			 * Read the message from the server and determine the appropriate message to send back 
			 */
			try {
				
				Rp.ProcessReadLine(in.readLine());
				
			} catch (IOException ie) {
				
				System.out.println("broker child Thread unable to read msg...");
				//ie.printStackTrace();
				
			}
			/*
			 * Need to send ERROR message
			 */
			if (Rp.sendError) {
				
				outputLine = "ERROR " + Rp.ErrorCode +"\n";
				
				out.print(outputLine);
				
				out.flush();
				
				Rp.sendError = false;
				
			} else if (Rp.sendStatus) {
				/*
				 * Need to send STATUS message
				 */
				
				if (Rp.Status) {
					
					outputLine = "STATUS TRUE\n";
					
				} else {
					
					outputLine = "STATUS FALSE\n";
					
					Rp.Status = true;
				}
				
				out.print(outputLine);
				
				out.flush();
				
				Rp.sendStatus = false;
				
			} else if (Rp.sendQueryReply) {
				/*
				 * Need to send QUERY-REPLY message
				 */
				
				int count = 0;
				
				
				ArrayList<Integer> BufferIndex = new ArrayList<Integer>(); 
				/*
				 * Need to lock the shared resource RegisterBuffer, as it can be accessed by
				 * multiple broker child threads.
				 */
				broker.LockRegister.readLock().lock();
				
				try {
					
					if (!broker.RegisterBuffer.isEmpty()) {
						
						int s = broker.RegisterBuffer.size();
						
						for (int i = 0; i < s; i++) {
							
							if (Rp.lineArray[2].equals("*")) {
								/*
								 * If second string from QUERY is *, then just count all the Register triples
								 * matching the first string from QUERY.
								 */
								if (broker.RegisterBuffer.get(i)[0].equals(Rp.lineArray[1])) { 
									count++;
									BufferIndex.add(i);
									
								}
								
							} else {
								/*
								 * If second string from QUERY is not *, then count all the Register triples
								 * matching the first string and the second string from QUERY.
								 */
								if ((broker.RegisterBuffer.get(i)[0].equals(Rp.lineArray[1])) && (broker.RegisterBuffer.get(i)[1].equals(Rp.lineArray[2]) )) { 
									count++;
									BufferIndex.add(i);
								}
								
							}
							
						}
						/*
						 * lineArray[0] contains the Random Alpha Numeric - Transaction Id generated by server
						 */
						outputLine = "QUERY-REPLY " + Rp.lineArray[0] + " " + count + "\n";
						
						out.print(outputLine);
						
						out.flush();
						
						for (int j = 0; j < count; j++) {
							/*
							 * Send as many RESPONSES as count of triples
							 */
							outputLine = "RESPONSE " + Rp.lineArray[0] + " " + (j+1) + " " + broker.RegisterBuffer.get(BufferIndex.get(0))[0] + " " + broker.RegisterBuffer.get(BufferIndex.get(0))[1] +"\n";
							
							out.print(outputLine);
							
							out.flush();
							
							BufferIndex.remove(0);
							
						}
					
					} else {
						
						outputLine = "ERROR 0x002\n";;
						
						out.print(outputLine);
						
						out.flush();
						
					}
					
				} finally {
					
					broker.LockRegister.readLock().unlock();
					
				}
				
				Rp.sendQueryReply = false;
		
			} else if(Rp.sendOK){
				
				outputLine = "OK\n";
				
				out.print(outputLine);
				
				out.flush();	
				
				Rp.sendOK = false;
				
				
			} else if(!Rp.ReceivedBye){  		// Server could have received BYE after entering the while loop..
				/*
				 * Need to send error stating that protocol message sent by server does not match
				 * any protocol sequence specified [Neither QUERY nor REGISTER nor REMOVE nor BYE] .
				 */
				outputLine = "ERROR 0x005\n";
				
				out.print(outputLine);
				
				out.flush();
				
			}

		}
	
		outputLine = "LATER\n";
	
		out.print(outputLine);
	
		out.flush();
	
		try {
			
			String clientName = connectionSocket.getInetAddress().getHostName();
			
			broker.LockRegister.writeLock().lock();
				
				try {
					
					if (!broker.RegisterBuffer.isEmpty()) {
						
						
						for (int i = 0; i < broker.RegisterBuffer.size(); i++) {
							
							if (broker.RegisterBuffer.get(i)[2].equals(clientName)) {
								
								broker.RegisterBuffer.remove(i);
							
							}
						}
						
					}
			
				} finally {
					
					broker.LockRegister.writeLock().unlock();
					
				}
			 
			
			in.close();
		
			out.close();
			
			connectionSocket.close();
			
			System.out.println("Remote Connection Closed!");
			
			/*
			 * The count for number of server child threads must be locked,
			 * as it can be accessed by multiple server child threads at the same time.
			 */
			
			broker.LockchildThreads.writeLock().lock();
			
			try {
				
				broker.childThreads--;
				
			} finally {
				
				broker.LockchildThreads.writeLock().unlock();
				
			}
			
			
		} catch (IOException ie) {
			
			System.out.println("broker child Thread unable to close connections...");
			//ie.printStackTrace();
			
		} 
		
	}

}
